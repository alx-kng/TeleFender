package com.telefender.phone.data.tele_database.client_daos

import androidx.room.Dao
import androidx.room.Transaction
import com.telefender.phone.data.server_related.json_classes.ServerData
import com.telefender.phone.data.tele_database.MutexType
import com.telefender.phone.data.tele_database.TeleLocks.mutexLocks
import com.telefender.phone.data.tele_database.entities.*
import com.telefender.phone.data.tele_database.entities.CallDetail
import com.telefender.phone.misc_helpers.TeleHelpers
import kotlinx.coroutines.delay
import kotlinx.coroutines.sync.withLock
import timber.log.Timber


/**
 * Contains most high level functions related to changes to our Tele database. Note that if you
 * want to expose a function marked as a Transaction, you must indicate the function as "open"?
 */
@Dao
abstract class ChangeAgentDao: ExecuteAgentDao, ExecuteQueueDao, UploadChangeQueueDao,
    UploadAnalyzedQueueDao, ChangeLogDao, AnalyzedNumberDao, CallDetailDao, ErrorQueueDao {

    private val retryAmount = 3

    /**
     * TODO: Double check changeFromServer(). Preliminary tests have passed.
     *
     * Function to handle a data downloaded from server. Adds data to the ExecuteQueue. We don't
     * need mutexSync here because downloaded CallDetails / AnalyzedNumbers are separate from
     * user's CallDetails and AnalyzedNumbers and won't affect their sync.
     * Also, although we technically don't need to retry here (as the DownloadPostRequest keeps
     * retrying with the lastServerRowID), we still retry here to decrease load on server (by not
     * re-requesting unnecessarily).
     */
    suspend fun changeFromServer(serverData: ServerData) : Boolean {
        // Reset current ErrorLog before change insertion just be safe.
        var currErrorLog : ErrorQueue? = null

        for (i in 1..retryAmount) {
            try {
                currErrorLog = changeFromServerHelper(serverData) ?: return true

                throw Exception("linkedRowID was -1 (unsuccessful insert)")
            } catch (e: Exception) {
                Timber.i("${TeleHelpers.DEBUG_LOG_TAG}: " +
                    "changeFromServer() RETRYING... ${e.message}")
                delay(2000)
            }
        }

        /*
        If the current ErrorQueue log is not null, then insert into database. let format is used
        because a simple if-null check can't guarantee that the error log won't be changed by the
        time the if-block is entered.
         */
        currErrorLog?.let { insertErrorLog(it) }

        return false
    }

    /**
     * TODO: Should we put an extra check to prevent NON_CONTACT_UPDATE changes from server being
     *  stored / executed.
     */
    @Transaction
    open suspend fun changeFromServerHelper(serverData: ServerData) : ErrorQueue? {
        val dataType = serverData.getGenericDataType()
            ?: throw Exception("genericDataType = ${serverData.type} is invalid!")

        // rowID of data in respective table. Used in ExecuteQueue for referencing a row.
        val linkedRowID: Long

        Timber.i("${TeleHelpers.DEBUG_LOG_TAG}: changeFromServer() - serverRowID: ${serverData.serverRowID}}")

        /*
        The rowID = 0 resets downloaded rowID's, which conflict with user's own rowID PK. This way,
        when the ChangeLog is inserted, another valid rowID will be autogenerated. Additionally,
        the linkedRowID < 0 checks if the insertion of data was successful, as insert functions
        will usually return -1 if the data was not inserted correctly (mostly likely due to a
        violation of the IGNORE conflict strategy.
         */
        when(dataType) {
            GenericDataType.CHANGE_DATA -> mutexLocks[MutexType.CHANGE]!!.withLock {
                with(serverData.changeLog!!) {
                    /**
                     * We don't check if ChangeLog should be stored in database for changes that
                     * come from the server, as server changes are executed through the execute
                     * queue, which requires the ChangeLog to be stored in database.
                     */
                    this.rowID = 0
                    linkedRowID = insertChangeLog(this)

                    if (linkedRowID < 0) {
                        Timber.i("${TeleHelpers.DEBUG_LOG_TAG}: " +
                            "insertChangeLog() failed! with $this")

                        return ErrorQueue.create(
                            instanceNumber = getUserNumber()!!,
                            serverRowID = serverData.serverRowID,
                            errorType = ErrorType.DOWNLOAD_ERROR,
                            errorMessage = "insertChangeLog() failed",
                            errorDataType = dataType,
                            errorDataJson = this.toJson()
                        )
                    }
                }
            }
            GenericDataType.ANALYZED_DATA -> mutexLocks[MutexType.ANALYZED]!!.withLock {
                with(serverData.analyzedNumber!!) {
                    this.rowID = 0
                    linkedRowID = insertAnalyzedNum(this)

                    if (linkedRowID < 0) {
                        Timber.i("${TeleHelpers.DEBUG_LOG_TAG}: insertAnalyzedNum() failed! with $this")

                        return ErrorQueue.create(
                            instanceNumber = getUserNumber()!!,
                            serverRowID = serverData.serverRowID,
                            errorType = ErrorType.DOWNLOAD_ERROR,
                            errorMessage = "insertAnalyzedNum() failed",
                            errorDataType = dataType,
                            errorDataJson = this.toJson()
                        )
                    }
                }
            }
            GenericDataType.LOG_DATA -> mutexLocks[MutexType.CALL_DETAIL]!!.withLock {
                with(serverData.callDetail!!) {
                    this.rowID = 0
                    linkedRowID = insertCallDetailIgnore(this)

                    if (linkedRowID < 0) {
                        Timber.i("${TeleHelpers.DEBUG_LOG_TAG}: insertCallDetailIgnore() failed! with $this")

                        return ErrorQueue.create(
                            instanceNumber = getUserNumber()!!,
                            serverRowID = serverData.serverRowID,
                            errorType = ErrorType.DOWNLOAD_ERROR,
                            errorMessage = "insertCallDetailIgnore() failed",
                            errorDataType = dataType,
                            errorDataJson = this.toJson()
                        )
                    }
                }
            }
        }

        mutexLocks[MutexType.EXECUTE]!!.withLock {
            val execLog = ExecuteQueue.create(
                serverRowID = serverData.serverRowID,
                genericDataType = dataType,
                linkedRowID = linkedRowID
            )
            insertQTE(execLog)
        }

        mutexLocks[MutexType.STORED_MAP]!!.withLock {
            updateStoredMap(lastServerRowID = serverData.serverRowID)
        }

        return null
    }

    /**
     * TODO: Modify or create new UploadLog to upload CallDetails. If not, then Transaction may
     *  be unnecessary.
     *
     * Handles new calls from client. Should only be called for syncing call logs. Returns whether
     * or not the CallDetail was inserted or not (may not be inserted if already synced).
     *
     * NOTE: Throws Exception if the Sync didn't go through, so higher level function must wrap
     * with try-catch.
     *
     * NOTE: if you would like to retry the transaction, you must do so yourself in the caller
     * function.
     */
    @Transaction
    open suspend fun callFromClient(callDetail: CallDetail) : Boolean {
        val inserted: Boolean
        mutexLocks[MutexType.NOTIFY_ITEM]!!.withLock {
            mutexLocks[MutexType.ANALYZED]!!.withLock {
                mutexLocks[MutexType.CALL_DETAIL]!!.withLock {
                    inserted = localLogInsert(callDetail)
                }
            }
        }

        return inserted
    }

    /**
     * TODO: Maybe rename this to immediateChange(), as some changes initiated from server may be
     *  executed here. The main thing is that the change is executed directly rather than going
     *  through execute queue first.
     *
     * TODO: Debating whether or not we should handle default database changes here to. But on
     *  second thought, since this a DAO, we shouldn't mix between our database and the default
     *  database. Perhaps we should make an enveloping function in the repository or something
     *  to call our changeFromClient() and handle the default database changes. Would have to
     *  check if the thing is from sync or not (which we luckily already have the infrastructure
     *  for).
     *
     * Function to handle a change (as a ChangeLog) from Client.
     * Inserts changes into actual tables (e.g., Instance, Contact, etc...) and adds change
     * to the ChangeLog and UploadChangeQueue. We can put Transaction over changeFromClient() because
     * we know there won't be any instance delete changes from client. Moreover, we should pass
     * in instanceNumber no matter what, so that we know whether the change was associated with
     * users direct contacts or with tree contacts.
     *
     * NOTE: When a direct contact change occurs, the
     * change is locked with mutexSync to prevent any parallelism problems with the sync process.
     * Since tree contact changes don't affect sync, we have no need to wrap with mutexSync (which
     * also practically restricts to one client side change at a time), which also makes the rare
     * case of a tree instance delete not super blocking to the database.
     *
     * NOTE: If changeFromClient() fails [retryAmount], then it also throws an error if
     * [bubbleError] is true so that the enclosing function can do a larger retry (for the
     * larger process) if it wants to.
     */
    suspend fun changeFromClient(
        changeLog: ChangeLog,
        fromSync: Boolean = false,
        bubbleError: Boolean = false
    ) {
        for (i in 1..retryAmount) {
            try {
                changeFromClientHelper(changeLog, fromSync)
                break
            } catch (e: Exception) {
                /*
                We need to throw an Exception here so that the enclosing syncContacts() can retry
                if the lower level changeFromClient() fails too many times.
                 */
                if (i == retryAmount && bubbleError) throw Exception("changeFromClient() - ${e.message}")

                Timber.i("${TeleHelpers.DEBUG_LOG_TAG}: " +
                    "changeFromClient() RETRYING... ${e.message}")
                delay(2000)
            }
        }
    }

    /**
     * TODO: Should we check if inserts and updates went through?
     */
    @Transaction
    open suspend fun changeFromClientHelper(changeLog: ChangeLog, fromSync: Boolean) {
        with(changeLog) {
            /*
            fromSync indicates whether or not the change was initiated from a sync. As mentioned
            in TableSynchronizer, the final sync queries (e.g., inserting into our database if we
            don't have it but the default database does) need to be uninterrupted by other insert
            / delete contact number queries. We can fix this by using the mutexSync lock. However,
            since we will be directly using the mutexSync inside TableSynchronizer, we need to
            make sure the lock isn't called again when it reaches changeFromClient().
             */
            if (fromSync || instanceNumber != getUserNumber()) {
                executeChange(changeLog)
            } else {
                mutexLocks[MutexType.SYNC]!!.withLock {
                    executeChange(changeLog)
                }
            }

            /**
             * Checks if ChangeLog should be stored in database. Any ChangeLogs that pass this point
             * should be stored in database.
             */
            if (!shouldStore(changeLog)) return

            // rowID of data in respective table. Used in upload queues for referencing a row.
            val linkedRowID: Long

            // Need to insert ChangeLog before inserting QTU so that rowID gets set.
            mutexLocks[MutexType.CHANGE]!!.withLock {
                linkedRowID = insertChangeLog(changeLog)
            }

            val changeType = this.getChangeType()

            // No need to upload non-contact / parameter updates since they don't affect other users.
            if (changeType != ChangeType.NON_CONTACT_UPDATE
                && changeType != ChangeType.PARAMETER_UPDATE
            ) {
                mutexLocks[MutexType.UPLOAD_CHANGE]!!.withLock {
                    val upLog = UploadChangeQueue(linkedRowID = linkedRowID)
                    insertChangeQTU(upLog)
                }
            }
        }
    }

    /**
     * Returns whether or not ChangeLog should be stored in database or not. This is mainly for
     * NON_CONTACT_UPDATES, where certain SAFE_ACTIONS are not crucial to store (e.g., SEEN or
     * SMS_SENT), as we don't want unimportant ChangeLogs to flood the database.
     */
    private fun shouldStore(changeLog: ChangeLog) : Boolean {
        if (changeLog.getChangeType() != ChangeType.NON_CONTACT_UPDATE) {
            return true
        }

        val safeAction = changeLog.getChange()?.getSafeAction()
        return safeAction != SafeAction.SEEN
            && safeAction != SafeAction.SMS_SENT
            && safeAction != SafeAction.SMS_REQUEST
    }
}